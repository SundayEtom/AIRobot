#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <random>
#include <regex>

#include <cstdlib>
#include <cstring>
#include "includes/airobot.hpp"

using namespace std;


int main(int argc, char *argv[]){
    if(argc < 2){
        cerr<<"Usage: AIRobot <source_file>"<<endl;
        return 1;
    }

    XMLDom dom(argv[1], "robot", true);
    bool compile = false;
    if(argc > 2){
        if(strcmp(argv[2], "-c") == 0)
            compile = true;
    }

    if(!dom.is_empty()){
        if(initialize(dom)){
            if(parse_robot(dom)){
                de_initialize(compile);
            }
        }
    }
    else{
        cerr << "DOM is empty." << endl;
    }
    return 0;
}




/*
* Initialize the robot compiler
*/
bool initialize(XMLDom dom){
    robotName = dom.getAttribute("name");
    outputCpp.open(outputDir + robotName + ".cpp", ios::trunc);
    outputHpp.open(outputDir + robotName + ".hpp", ios::trunc);
    bool written = false;
    string s;

    if(outputHpp.is_open()){
        s = "#ifndef " +  robotName + "_hpp\n#define " + robotName + "_hpp\n\n"
            "#include <string>\n"
            "#include <cstdlib>\n"
            "#include <ctime>\n"
            "#include <vector>\n\n"
            "#include <regex>\n\n"
            "#include <fstream>\n\n"
            "bool runRobot(void);\n"
            "bool repeatedPrompt(std::string category);\n"
            "std::string buildPattern(std::string str, std::vector<std::string> vals);\n";

        outputHpp << s << endl;
        written = true;
    }

    if(outputCpp.is_open()){
        s = "// AIRobot file auto-generated by AIRobot compiler\n"
            "#include <iostream>\n"
            "#include \"" + robotName + ".hpp\"\n\n"
            "using namespace std;\n\n"

            "/* ************************************************************************** */\n"
            "class Category{\n"
            "\tprivate:\n"
            "\t\tstring catName;\n"
            "\t\tvector<string> prompts;\n"
            "\t\tvector<string> responses;\n\n"

            "\tpublic:\n"
            "\t\tCategory(string name, "
            "std::initializer_list<string> promptList, "
            "std::initializer_list<string> resList){\n"
            "\t\t\tthis->catName = name;\n"
            "\t\t\tthis->addPrompts(promptList);\n"
            "\t\t\tthis->addResponses(resList);\n"
            "\t\t}\n\n"

            "\t\t~Category(){\n"
            "\t\t\tdelete this;\n"
            "\t\t}\n\n"

            "\t\tvoid addPrompts(std::initializer_list<string> promptList){\n"
            "\t\t\tfor(string p : promptList)\n"
            "\t\t\t\tprompts.push_back(p);\n"
            "\t\t}\n\n"

            "\t\tvoid addResponses(std::initializer_list<string> resList){\n"
            "\t\t\tfor(string r : resList)\n"
            "\t\t\t\tresponses.push_back(r);\n"
            "\t\t}\n\n"

            "\t\tstring getCategory(void){\n"
            "\t\t\treturn catName;\n"
            "\t\t}\n\n"

            "\t\tvector<string> getPrompts(void){\n"
            "\t\t\treturn prompts;\n"
            "\t\t}\n\n"

            "\t\tstring getResponse(string tgt_prompt, string input){\n"
            "\t\t\tsrand((int)time(0));\n"
            "\t\t\tint res_count = responses.size();\n"
            "\t\t\tint index = rand() % res_count;\n"
            "\t\t\tstring res = responses.at(index);\n"
            "\t\t\tsmatch matches;\n"
            "\t\t\tregex pat{tgt_prompt};\n\n"
            "\t\t\tif(regex_search(input, matches, pat)){\n"
            "\t\t\t\tvector<string> values;\n"
            "\t\t\t\tfor(int i=1; i<matches.size(); ++i){\n"
            "\t\t\t\t\tvalues.push_back(matches[i]);\n"
            "\t\t\t\t}\n"
            "\t\t\t\tres = ::buildPattern(res, values);\n"
            "\t\t\t}\n"
            "\t\t\treturn res;\n"
            "\t\t}\n"
            "};\n\n"

            "/* ************************************************************************** */\n\n"
            "vector<Category*> categories;\n"
            "vector<string> promptHistory;\n\n"
            "int main(int argc, char *argv[]){\n";

        outputCpp << s;
        written =  true;
    }
    return written;
}



bool de_initialize(bool compile){
    outputHpp << "#endif" << endl << endl;

    string s;
    s = "\n\trunRobot();\n"
        "\treturn 0;\n}\n\n"
        "/* ************************************************************************** */\n\n"

        "bool runRobot(void){\n"
        "\tstring prompt;\n\n"
        "\tLoop: while(true){\n"
        "\t\tcout << \"Ask Me: \";\n"
        "\t\tgetline(cin, prompt);\n"
        "\t\tif(prompt == \"quit\") break;\n"
        "\t\tfor(Category *c : categories){\n"
        "\t\t\tfor(string s : c->getPrompts()){\n"
        "\t\t\t\tregex pat{s};\n"
        "\t\t\t\tsmatch matches;\n"
        "\t\t\t\tif(regex_match(prompt, matches, pat)){\n"
        "\t\t\t\t\tif(repeatedPrompt(c->getCategory())){\n"
        "\t\t\t\t\t\tcout << \"I already told you \";\n"
        "\t\t\t\t\t}\n"
        "\t\t\t\t\tstring res = c->getResponse(s, prompt);\n"
        "\t\t\t\t\tregex codepat{\"<code lang[[:s:]]*=[[:s:]]*'(.*?)'[[:s:]]+clean[[:s:]]*=[[:s:]]*'(.*?)'>(.*?)</code>\"};\n"
        "\t\t\t\t\tif(regex_search(res, matches, codepat)){\n"
        "\t\t\t\t\t\tstring lang = matches[1];\n"
        "\t\t\t\t\t\tstring clean = matches[2];\n"
        "\t\t\t\t\t\tres = matches[3];\n"
        "\t\t\t\t\t\tstring file = \"AIRobot\";\n"
        "\t\t\t\t\t\tif(lang == \"python\"){\n"
        "\t\t\t\t\t\t\tfile += \".py\";\n"
        "\t\t\t\t\t\t\tofstream os(file);\n"
        "\t\t\t\t\t\t\tif(os){\n"
        "\t\t\t\t\t\t\t\tos << \"print(\" << res << \")\";\n"
        "\t\t\t\t\t\t\t\tos.close();\n"
        "\t\t\t\t\t\t\t\tsystem((\"python \" + file).c_str());\n"
        "\t\t\t\t\t\t\t\tif(clean == \"true\") system((\"rm \" + file).c_str());\n"
        "\t\t\t\t\t\t\t}\n"
        "\t\t\t\t\t\t}\n"
        "\t\t\t\t\t\telse if(lang == \"cpp\"){\n"
        "\t\t\t\t\t\t\tfile += \".cpp\";\n"
        "\t\t\t\t\t\t\tofstream os(file);\n"
        "\t\t\t\t\t\t\tif(os){\n"
        "\t\t\t\t\t\t\t\tos << \"#include <iostream>\" << endl;\n"
        "\t\t\t\t\t\t\t\tos << \"using namespace std;\" << endl << endl;\n"
        "\t\t\t\t\t\t\t\tos << \"int main(int argc, char *argv[]){\" << endl;\n"
        "\t\t\t\t\t\t\t\tos << \"\tcout << \" << res << \" << endl;\"  << endl;\n"
        "\t\t\t\t\t\t\t\tos << \"\treturn 0;\" << endl;\n"
        "\t\t\t\t\t\t\t\tos << \"}\";\n"
        "\t\t\t\t\t\t\t\tos.close();\n"
        "\t\t\t\t\t\t\t\tsystem((\"g++ \" + file).c_str());\n"
        "\t\t\t\t\t\t\t\tsystem(\"./a.out \");\n"
        "\t\t\t\t\t\t\t\tif(clean == \"true\") system((\"rm *.out \" + file).c_str());\n"
        "\t\t\t\t\t\t\t}\n"
        "\t\t\t\t\t\t}\n"
        "\t\t\t\t\t\telse cout << \"Unknown language!\" << endl;\n"
        "\t\t\t\t\t}\n"
        "\t\t\t\t\telse cout << res << endl;\n"
        "\t\t\t\t\t//promptHistory.push_back(c->getCategory());\n"
        "\t\t\t\t}\n"
        "\t\t\t}\n"
        "\t\t}\n"
        "\t}\n\treturn true;\n}\n\n"
        "/* ************************************************************************** */\n\n"

        "bool repeatedPrompt(string category){\n"
        "\tfor(string s : promptHistory){\n"
        "\t\tif(s == category)\n"
        "\t\t\treturn true;\n"
        "\t}\n\n"
        "\treturn false;\n"
        "}\n\n"
        "/* ************************************************************************** */\n\n"

        "string buildPattern(string str, vector<string> vals){\n"
        "\tif(vals.empty()){\n"
        "\t\tcout << \"Values list is empty.\" << endl;\n"
        "\t\treturn \"\";\n"
        "\t}\n"
        "\tregex pat{\"(<number/>)|(<string/>)|(<mathop>)\"};\n"
        "\tstring s = str;\n"
        "\tfor(string val : vals){\n"
        "\t\ts = regex_replace(s, pat, val, regex_constants::format_first_only);\n"
        "\t}\n"
        "\treturn s;\n"
        "}\n\n"
        "/* ************************************************************************** */\n\n";

    outputCpp << s;
    outputCpp.close();
    outputHpp.close();

    if(compile){
        cout << "Compiling ..." << endl;
        system(("g++ " + outputDir + (string)robotName + ".cpp -o " +
            outputDir + (string)robotName + " -std=c++11").c_str());
    }

    cout << endl << "***************************************" << endl;
    cout << "Robot parsing and compilation complete." << endl;
    return true;
}



string parse_content(string content){
    regex numpat{"<number/>"}, strpat{"<string/>"}, mathop{"<mathop>"};
    string output = content;

    output = regex_replace(output, numpat, "([[:digit:]]+)");
    output = regex_replace(output, strpat, "(.*?)");
    output = regex_replace(output, mathop, "([\+-/\*]{1})");

    return output;
}



bool parse_robot(XMLDom dom){
    int cat_index = 0;
    string s = "\tCategory *cat;\n\n";

    for(XMLDom cat : dom.getChildren({"category"})){
        string cat_name = cat.getAttribute("name");
        if(cat_name.length() <= 0){
            cat_name = "category_" + to_string(cat_index);
            cat_index++;
        }

        for(XMLDom child : cat.getChildren({"prompt", "response"})){
            if(!child.is_empty()){
                if(child.getName() == "prompt"){
                    XMLDom anyof = child.getChild("anyof");
                    s += "\tcat = new Category(\n\t\t\"" + cat_name + "\"";

                    if(!anyof.is_empty()){
                        string promptList = "{ ";
                        for(XMLDom option : anyof.getChildren({"option"})){
                            string cont = parse_content(option.getContent());
                            promptList += "\"" + cont + "\", ";
                        }
                        promptList = promptList.replace(promptList.length()-2, 2, " }");
                        s += ", \n\t\t" + promptList;
                    }
                    else{
                        string cont = parse_content(child.getContent());
                        s += ", \n\t\t{ \"" + cont + "\" }";
                    }
                }
                else if(child.getName() == "response"){
                    XMLDom random = child.getChild("random");
                    if(!random.is_empty()){
                        string resList = "{ ";
                        for(XMLDom option : random.getChildren({"option"})){
                            string cont = option.getContent();
                            resList += "\"" + cont + "\", ";
                        }
                        resList = resList.replace(resList.length()-2, 2, " }");
                        s += ", \n\t\t" + resList;
                    }
                    else{
                        string cont = child.getContent();
                        s += ", \n\t\t{ \"" + cont + "\" }";
                    }
                }
            }
            else{
                // Simply ignore empty element
            }
        }

        s += "\n\t);\n\tcategories.push_back(cat);\n\n";
        outputCpp << s;
        s.clear();
    }
    return true;
}

